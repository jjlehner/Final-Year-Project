
module V2H.V2H where


import Control.Exception
import Control.Monad
import Control.Monad.Except qualified as Mtl
import Data.Function
import Data.ByteString.Lazy.Char8 qualified as LazyByteString
import              Data.Generics.Product
import V2H.Alex.Lexer qualified as Lexer
import V2H.Parser qualified as Parser
import V2H.IR qualified as IR
import V2H.IR.DataTypes qualified as IR
import V2H.IRGenerator as IR
import V2H.CodeGenerator
import V2H.Simulator.Signal
import Text.Pretty.Simple
import Language.Haskell.TH
import Language.Haskell.TH.Syntax

import Data.Either.Extra qualified as Either

import V2H.Transpile



safeReadFile filePath =
    Either.mapLeft show <$> readFileEither filePath
    where
        readFileEither :: FilePath -> IO (Either IOException LazyByteString.ByteString)
        readFileEither x = try $ LazyByteString.readFile x

-- | Debugging function to see what setup is generation
setupWriteOutput :: FilePath -> String -> [FilePath] -> Q [Dec]
setupWriteOutput outputFile toplevelModuleName sourceFilePaths = do
    autogeneratedTypesAndFunctions <- setup toplevelModuleName sourceFilePaths
    runIO $ writeFile outputFile $ pprint $ reverse autogeneratedTypesAndFunctions
    return []

-- | Top level entry function for generating type information using V2H
-- First argument is the toplevel module name of rtl design
-- Second argument is the list to all filepaths used in the design
setup :: String -> [FilePath] -> Q [Dec]
setup toplevelModuleName sourceFilePaths = do
    mapM_ addDependentFile sourceFilePaths
    eitherErrOrSourceCodes <- runIO $ traverse safeReadFile sourceFilePaths
    let eitherErrOrIRs = generateIRsFromSourceCodes toplevelModuleName =<< sequence eitherErrOrSourceCodes
    case eitherErrOrIRs of
        Left err -> do
                        runIO $ print err
                        runIO $ throwIO $ V2HCodeGenError err
                        return []
        Right (toplevelIR, irs) ->
            do
                let expandedIR = generateExpandedIR toplevelIR irs
                generateSignalSumTypesFromIRs irs toplevelIR (IR.ModuleInstanceIdentifierIR toplevelModuleName)
                            & liftM2 (++) (generateSignalIdentifiers expandedIR)
                            & liftM2 (++) (generateCircuitRecord [IR.ModuleInstanceIdentifierIR toplevelModuleName] irs toplevelIR)
                            & liftM2 (++) (generateConvertFromDynamicFunction (mkName "top") expandedIR )
                            & liftM2 (++) (generateConvertToDynamicFunction (mkName "staticRep") expandedIR)
                            & liftM2 (++) (generateEmptyValue expandedIR)
                            & liftM2 (++) (generateExpandedIRValue toplevelModuleName $ Either.fromRight' $ sequence eitherErrOrSourceCodes)
                            & liftM2 (++) (generateEval expandedIR)
                            & liftM2 (++) generateInitState